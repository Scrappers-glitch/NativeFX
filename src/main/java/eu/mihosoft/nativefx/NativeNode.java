/*
 * Copyright 2019-2019 Michael Hoffer <info@michaelhoffer.de>. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * If you use this software for scientific research then please cite the following publication(s):
 *
 * M. Hoffer, C. Poliwoda, & G. Wittum. (2013). Visual reflection library:
 * a framework for declarative GUI programming on the Java platform.
 * Computing and Visualization in Science, 2013, 16(4),
 * 181â€“192. http://doi.org/10.1007/s00791-014-0230-y
 */
/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package eu.mihosoft.nativefx;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.IntBuffer;
import java.util.Date;

import javafx.animation.Animation;
import javafx.animation.AnimationTimer;
import javafx.application.Platform;
import javafx.beans.value.ChangeListener;
import javafx.scene.Node;
import javafx.scene.image.ImageView;
import javafx.scene.image.PixelFormat;
import javafx.scene.image.WritableImage;
import javafx.scene.image.WritablePixelFormat;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;

public final class NativeNode extends Region {

    private final WritablePixelFormat<IntBuffer> format = PixelFormat.getIntArgbPreInstance();

    private WritableImage img;
    private ImageView view;

    private ByteBuffer buffer;
    private IntBuffer intBuf;

    public NativeNode(int key) {

        view = new ImageView();

        // ByteBuffer buffer = null;NativeBinding.getBuffer(key);
        // IntBuffer intBuf = null;buffer.order(ByteOrder.LITTLE_ENDIAN)
        // .asIntBuffer();

        Runnable r = () -> {

            NativeBinding.lock(key);
            boolean dirty = NativeBinding.isDirty(key);
            boolean isReady = NativeBinding.isBufferReady(key);

            if(!isReady) {
                System.out.println("> WARNING: buffer ready: " + isReady);
            }

            if (!dirty || !isReady) {
                NativeBinding.unlock(key);
                return;
            }

            int currentW = NativeBinding.getW(key);
            int currentH = NativeBinding.getH(key);

            // create new image instance if the image doesn't exist or
            // if the dimensions do not match
            if (img == null || Double.compare(currentW, img.getWidth()) != 0
                    || Double.compare(currentH, img.getHeight()) != 0) {

                System.out.println("  -> resize W: " + currentW + ", H: " + currentH);

                buffer = NativeBinding.getBuffer(key);
                intBuf = buffer.order(ByteOrder.LITTLE_ENDIAN).asIntBuffer();

                img = new WritableImage(currentW, currentH);
                view.setImage(img);

                // TODO improve layout (width or hight ...)
                view.fitWidthProperty().bind(widthProperty());
            }

            img.getPixelWriter().setPixels(0, 0, (int) img.getWidth(), (int) img.getHeight(), format, intBuf,
                    (int) img.getWidth());

                // we updated the image, not dirty anymore
                // NativeBinding.lock(key);
                NativeBinding.setDirty(key, false);

                int w = (int)getWidth();
                int h = (int)getHeight();

                if((w != NativeBinding.getW(key) || h != NativeBinding.getH(key)) && w > 0 && h > 0) {
                    System.out.println("> requesting buffer resize W: " + w + ", H: " + h);
                    NativeBinding.resize(key, w, h);
                    // buffer = null;
                    // intBuf = null;
                }

                NativeBinding.unlock(key);
                
        };

        new AnimationTimer() {
            @Override
            public void handle(long now) {
                r.run();
            }
        }.start();

        view.setStyle("-fx-border-color: red;");

        getChildren().add(view);
    }
}
